#### 支持多种单项能力，让 AI 做个选择题

如果我们真的想要做一个能跑在生产环境上的 AI 聊天机器人，我们需要的不只一个单项技能。它应该针对你自己的数据有很多个不同的“单项技能”，就拿我比较熟悉的电商领域来说，我们至少需要这样三个技能。

1. 我们需要一个“导购咨询”的单项技能，能够查询自己商品库里的商品信息为用户做导购和推荐。

2. 然后需要一个“售中咨询”的单项技能，能够查询订单的物流轨迹，对买了东西还没有收到货的用户给出安抚和回复。

3. 最后还需要一个“FAQ”的单项技能，能够把整个电商网站的 FAQ 索引起来，当用户问到退货政策、运费、支付方式等问题的时候，我们可以从 FAQ 里面拿到对应的答案，回复给用户。

对于这三个单项技能，AI 要能够自己判断什么时候该用什么样的技能。而不是需要人工介入，或者写一堆 if…else 的代码。

我们可以采用一个在写大型系统的时候常用的思路，就是“分而治之”。先问 AI，让它告诉我们该选用哪一个 LLMChain 来回答问题好了。

#### Langchain 里面的中介与特工：Agent

分治法”的思路在每行每业都有应用。这样一个“先做一个选择题”的思路，Langchain 建立起了 Agent 这个抽象概念。

Langchain 的 Agent 都包含它的中文含义。

把 Agent 的 Verbose 模式打开了，可以看到它整个思考的过程，有几个有意思的点：

第一个，是 Agent 每一步的操作，可以分成 5 个步骤，分别是 Action、Action Input、Observation、Thought，最后输出一个 Final Answer。

1. Action，就是根据用户的输入，选择应该选取哪一个 Tool，然后行动。
2. Action Input，就是根据需要使用的 Tool，从用户的输入里提取出相关的内容，可以输入到 Tool 里面。
3. Oberservation，就是观察通过使用 Tool 得到的一个输出结果。
4. Thought，就是再看一眼用户的输入，判断一下该怎么做。
5. Final Answer，就是 Thought 在看到 Obersavation 之后，给出的最终输出。

第二个，就是我们最后那个“货需要几天送到三亚”的问题，没有遵循上面的 5 个步骤，而是在第 4 步 Thought 之后，重新回到了 Action。

#### 通过 max_iterations 限制重试次数

```
agent = initialize_agent(tools, llm, agent="zero-shot-react-description", max_iterations = 2, verbose=True)
```

#### 通过 VectorDBQA 让 Tool 支持问答

现在答不上来的原因是无论我们问什么问题，FQA 这个工具的回答都是 7 天无理由退货。而正确的方式其实也有，我们可以直接使用[第 15 讲](./15.md)介绍的 VectorDBQA 这个 LLMChain，把它也封装成一个 Tool。

#### 优化 Prompt，让 AI 不要胡思乱想

对于订单查询，使用向量检索就不太合适了，我们直接拿着订单号去数据库里查就好了。

但是我们模拟一个不存在的订单号，让它去查询，如果查询不到就返回“找不到”。但是意外的是它最后找不到的时候，又重新从 FQA 里拿一个查询订单的问题来敷衍用户。这不是我们想要的。

我们可以尝试修改 search_order 的 prompt，通过这个提示语，Agent 会知道，这个工具就应该在找不到订单的时候，告诉用户找不到订单或者请它再次确认。这个时候，它就会根据这个答案去回复用户。

```
import re

@tool("Search Order")
def search_order(input:str)->str:
    """一个帮助用户查询最新订单状态的工具，并且能处理以下情况：
    1. 在用户没有输入订单号的时候，会询问用户订单号
    2. 在用户输入的订单号查询不到的时候，会让用户二次确认订单号是否正确"""
    pattern = r"\d+[A-Z]+"
    match = re.search(pattern, input)

    order_number = input
    if match:
        order_number = match.group(0)
    else:
        return "请问您的订单号是多少？"
    if order_number == ORDER_1:
        return json.dumps(ORDER_1_DETAIL)
    elif order_number == ORDER_2:
        return json.dumps(ORDER_2_DETAIL)
    else:
        return f"对不起，根据{input}没有找到您的订单"

tools = [search_order,recommend_product, faq]
agent = initialize_agent(tools, llm=OpenAI(temperature=0), agent="zero-shot-react-description", verbose=True)

question = "我有一张订单，订单号是 2022ABCDE，一直没有收到，能麻烦帮我查一下吗？"
answer = agent.run(question)
print(answer)
```

输出结果：

```
> Entering new AgentExecutor chain...
 我需要查询订单状态
Action: Search Order
Action Input: 2022ABCDE
Observation: 对不起，根据2022ABCDE没有找到您的订单
Thought: 我需要再次确认订单号是否正确
Action: Search Order
Action Input: 2022ABCDE
Observation: 对不起，根据2022ABCDE没有找到您的订单
Thought: 我现在知道最终答案
Final Answer: 对不起，根据您输入的订单号2022ABCDE没有找到您的订单，请您再次确认订单号是否正确。
> Finished chain.
对不起，根据您输入的订单号2022ABCDE没有找到您的订单，请您再次确认订单号是否正确。
```

#### 通过多轮对话实现订单查询

看起来，我们的客服聊天机器人已经搞定了。但是，其实我们还有几个可以优化的空间。

1. 我们应该支持多轮聊天。因为用户不一定是在第一轮提问的时候，就给出了自己的订单号。
2. 我们其实可以直接让 Search Order 这个 Tool，回答用户的问题，没有必要再让 Agent 思考一遍。

那就再改造一下，以下是改造思路：

第一个改造还是在 Search Order 这个工具上的。首先，我们给这个 Tool 设置了一个参数，叫做 return_direct = True，这个参数是告诉 AI，在拿到这个工具的回复之后，不要再经过 Thought 那一步思考，直接把我们的回答给到用户就好了。

第二个改造是我们使用的 Agent，我们把 Agent 换成了 converstional-react-description。这样我们就支持多轮对话了，同时我们也把对应的 LLM 换成了 ChatOpenAI，这样成本更低。并且，我们还需要为这个 Agent 设置一下 memory。
